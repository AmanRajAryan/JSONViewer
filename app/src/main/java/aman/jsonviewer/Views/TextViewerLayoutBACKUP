package aman.jsonviewer;

import android.content.Context;
import android.graphics.Rect;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.VelocityTracker;
import android.view.View;
import android.view.ViewConfiguration;
import android.view.ViewGroup;
import android.widget.HorizontalScrollView;
import android.widget.OverScroller;
import androidx.annotation.NonNull;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

public class TextViewerLayout extends ViewGroup {
    private HorizontalScrollView horizontalScrollView;
    private RecyclerView recyclerView;
    private DampedScrollBar verticalScrollBar;
    private DampedScrollBar horizontalScrollBar;
    private TextLineAdapter adapter;

    private int maxContentWidth = 0;
    private static final int SCROLLBAR_SIZE = 64;

    private float lastTouchX;
    private float lastTouchY;
    private boolean isScrolling = false;
    private VelocityTracker velocityTracker;
    private OverScroller scroller;
    private static final int MIN_FLING_VELOCITY = 50;
    private static final int BASE_MAX_FLING_VELOCITY = 10000;
    private int maxFlingVelocity = BASE_MAX_FLING_VELOCITY;
    private int touchSlop;

    public TextViewerLayout(Context context) {
        super(context);
        init(context);
    }

    public TextViewerLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
        init(context);
    }

    private void init(Context context) {
        setWillNotDraw(false);
        setBackgroundColor(0xFF121212);
        
        // Get standard system touch slop
        touchSlop = ViewConfiguration.get(context).getScaledTouchSlop();

        scroller = new OverScroller(context);

        recyclerView = new RecyclerView(context);
        recyclerView.setLayoutManager(new LinearLayoutManager(context));
        recyclerView.setBackgroundColor(0xFF121212);
        recyclerView.setOverScrollMode(View.OVER_SCROLL_NEVER);
        recyclerView.setClipToPadding(false);
        recyclerView.setPadding(0, 0, SCROLLBAR_SIZE, 0);
        adapter = new TextLineAdapter();
        recyclerView.setAdapter(adapter);

        recyclerView.setLayoutParams(
                new android.widget.FrameLayout.LayoutParams(
                        android.widget.FrameLayout.LayoutParams.MATCH_PARENT,
                        android.widget.FrameLayout.LayoutParams.MATCH_PARENT));

        // --- STABLE FIX: Prevent Focus Snap ---
        horizontalScrollView = new HorizontalScrollView(context) {
            @Override
            public boolean requestChildRectangleOnScreen(View child, Rect rectangle, boolean immediate) {
                return false; 
            }
        };
        
        horizontalScrollView.setHorizontalScrollBarEnabled(false);
        horizontalScrollView.setOverScrollMode(View.OVER_SCROLL_NEVER);
        horizontalScrollView.setClipToPadding(false);
        horizontalScrollView.setPadding(0, 0, 0, SCROLLBAR_SIZE);
        horizontalScrollView.addView(recyclerView);
        addView(horizontalScrollView);

        verticalScrollBar = new DampedScrollBar(context, true);
        horizontalScrollBar = new DampedScrollBar(context, false);
        addView(verticalScrollBar);
        addView(horizontalScrollBar);

        recyclerView.addOnScrollListener(
                new RecyclerView.OnScrollListener() {
                    @Override
                    public void onScrolled(@NonNull RecyclerView rv, int dx, int dy) {
                        updateVerticalScrollBar();
                    }
                });

        horizontalScrollView
                .getViewTreeObserver()
                .addOnScrollChangedListener(this::updateHorizontalScrollBar);

        verticalScrollBar.setOnScrollListener(
                (delta, isDampingDisabled) -> {
                    int totalHeight = recyclerView.computeVerticalScrollRange();
                    int viewHeight = recyclerView.getHeight();
                    if (viewHeight == 0) return;

                    if (isDampingDisabled) {
                        int itemCount = adapter.getItemCount();
                        if (itemCount > 0) {
                            int targetPos = (int) (delta * (itemCount - 1));
                            RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager();
                            if (layoutManager instanceof LinearLayoutManager) {
                                ((LinearLayoutManager) layoutManager).scrollToPositionWithOffset(targetPos, 0);
                            }
                        }
                    } else {
                        float dampingFactor = calculateDampingFactor(totalHeight, viewHeight);
                        int scrollAmount = (int) (delta * dampingFactor);
                        recyclerView.scrollBy(0, scrollAmount);
                    }
                });

        horizontalScrollBar.setOnScrollListener(
                (delta, isDampingDisabled) -> {
                    int viewWidth = horizontalScrollView.getWidth();
                    int contentWidth = recyclerView.getWidth();
                    if (viewWidth == 0 || contentWidth == 0) return;

                    int maxScroll = Math.max(0, contentWidth - viewWidth);

                    if (isDampingDisabled) {
                        int targetScroll = (int) (delta * maxScroll);
                        horizontalScrollView.scrollTo(targetScroll, 0);
                    } else {
                        float dampingFactor = calculateDampingFactor(contentWidth, viewWidth);
                        int currentScroll = horizontalScrollView.getScrollX();
                        int scrollAmount = (int) (delta * dampingFactor);
                        int newScroll = currentScroll + scrollAmount;
                        newScroll = Math.max(0, Math.min(newScroll, maxScroll));
                        horizontalScrollView.scrollTo(newScroll, 0);
                    }
                });
    }

    private float calculateDampingFactor(int contentSize, int viewSize) {
        if (contentSize <= viewSize) return 1.0f;
        return Math.min(10.0f, (float) Math.sqrt((double) contentSize / viewSize));
    }

    public void loadText(String text, boolean enableWrapping) {
        String[] lines = text.split("\n");
        adapter.setEnableWrapping(enableWrapping);
        adapter.setLines(lines);
        adapter.calculateMaxWidth(getContext());
        maxContentWidth = adapter.getMaxLineWidth();

        float scaleFactor = Math.min(3.5f, (float) Math.sqrt(lines.length / 100.0));
        maxFlingVelocity = (int) (BASE_MAX_FLING_VELOCITY * scaleFactor);

        if (!enableWrapping) {
            int totalWidth = maxContentWidth + SCROLLBAR_SIZE + 120;
            recyclerView.setMinimumWidth(totalWidth);
            recyclerView.setLayoutParams(
                    new android.widget.FrameLayout.LayoutParams(
                            totalWidth, 
                            android.widget.FrameLayout.LayoutParams.MATCH_PARENT));
        } else {
            recyclerView.setLayoutParams(
                    new android.widget.FrameLayout.LayoutParams(
                            android.widget.FrameLayout.LayoutParams.MATCH_PARENT,
                            android.widget.FrameLayout.LayoutParams.MATCH_PARENT));
        }

        recyclerView.requestLayout();
        horizontalScrollView.requestLayout();
        adapter.notifyDataSetChanged();

        postDelayed(
                () -> {
                    updateVerticalScrollBar();
                    updateHorizontalScrollBar();
                },
                100);
    }

    public void loadText(String text) {
        loadText(text, false);
    }

    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
        int width = r - l;
        int height = b - t;

        horizontalScrollView.layout(0, 0, width, height);

        int scrollViewRight = width - SCROLLBAR_SIZE;
        int scrollViewBottom = height - SCROLLBAR_SIZE;
        verticalScrollBar.layout(scrollViewRight, 0, width, scrollViewBottom);
        horizontalScrollBar.layout(0, scrollViewBottom, scrollViewRight, height);

        if (changed) {
            post(() -> {
                updateVerticalScrollBar();
                updateHorizontalScrollBar();
            });
        }
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        int width = MeasureSpec.getSize(widthMeasureSpec);
        int height = MeasureSpec.getSize(heightMeasureSpec);

        horizontalScrollView.measure(
                MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY),
                MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY));

        verticalScrollBar.measure(
                MeasureSpec.makeMeasureSpec(SCROLLBAR_SIZE, MeasureSpec.EXACTLY),
                MeasureSpec.makeMeasureSpec(height - SCROLLBAR_SIZE, MeasureSpec.EXACTLY));

        horizontalScrollBar.measure(
                MeasureSpec.makeMeasureSpec(width - SCROLLBAR_SIZE, MeasureSpec.EXACTLY),
                MeasureSpec.makeMeasureSpec(SCROLLBAR_SIZE, MeasureSpec.EXACTLY));

        setMeasuredDimension(width, height);
    }

    private void updateVerticalScrollBar() {
        int totalHeight = recyclerView.computeVerticalScrollRange();
        int viewHeight = recyclerView.computeVerticalScrollExtent();
        int scrollOffset = recyclerView.computeVerticalScrollOffset();

        if (viewHeight == 0 || totalHeight == 0) return;

        float ratio = Math.min(1.0f, (float) viewHeight / totalHeight);
        float dampingFactor = calculateDampingFactor(totalHeight, viewHeight);

        verticalScrollBar.updateScrollBar(ratio, scrollOffset, totalHeight, dampingFactor);
    }

    private void updateHorizontalScrollBar() {
        int viewWidth = horizontalScrollView.getWidth();
        int contentWidth = recyclerView.getWidth();

        if (viewWidth == 0 || contentWidth == 0) return;

        float ratio = Math.min(1.0f, (float) viewWidth / contentWidth);
        int scrollOffset = horizontalScrollView.getScrollX();
        float dampingFactor = calculateDampingFactor(contentWidth, viewWidth);

        horizontalScrollBar.updateScrollBar(ratio, scrollOffset, contentWidth, dampingFactor);
    }

    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        if (isTouchOnScrollBar(ev, verticalScrollBar)) return false;
        if (isTouchOnScrollBar(ev, horizontalScrollBar)) return false;

        final int action = ev.getAction();
        
        if (action == MotionEvent.ACTION_MOVE && isScrolling) {
            return true;
        }

        switch (action & MotionEvent.ACTION_MASK) {
            case MotionEvent.ACTION_DOWN:
                lastTouchX = ev.getX();
                lastTouchY = ev.getY();
                isScrolling = false;
                scroller.abortAnimation();
                // STABLE FIX: Return false to let children (TextViews) receive touch
                return false; 

            case MotionEvent.ACTION_MOVE:
                final float x = ev.getX();
                final float y = ev.getY();
                final float dx = Math.abs(x - lastTouchX);
                final float dy = Math.abs(y - lastTouchY);
                
                if (dx > touchSlop || dy > touchSlop) {
                    isScrolling = true;
                    lastTouchX = x;
                    lastTouchY = y;
                    return true;
                }
                break;
        }
        return false;
    }

    private boolean isTouchOnScrollBar(MotionEvent ev, View scrollBar) {
        int[] location = new int[2];
        scrollBar.getLocationOnScreen(location);
        int x = (int) ev.getRawX();
        int y = (int) ev.getRawY();
        return x >= location[0] && x <= location[0] + scrollBar.getWidth()
                && y >= location[1] && y <= location[1] + scrollBar.getHeight();
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        if (velocityTracker == null) velocityTracker = VelocityTracker.obtain();
        velocityTracker.addMovement(event);

        switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN:
                if (!scroller.isFinished()) scroller.abortAnimation();
                lastTouchX = event.getX();
                lastTouchY = event.getY();
                isScrolling = true;
                return true;

            case MotionEvent.ACTION_MOVE:
                if (!isScrolling) {
                    isScrolling = true;
                    lastTouchX = event.getX();
                    lastTouchY = event.getY();
                    return true;
                }
                
                float deltaX = lastTouchX - event.getX();
                float deltaY = lastTouchY - event.getY();
                
                // STABLE FIX: Use scrollBy to respect native bounds logic
                recyclerView.scrollBy(0, (int) deltaY);
                horizontalScrollView.scrollBy((int) deltaX, 0);

                lastTouchX = event.getX();
                lastTouchY = event.getY();
                updateVerticalScrollBar();
                updateHorizontalScrollBar();
                return true;

            case MotionEvent.ACTION_UP:
                if (isScrolling) {
                    velocityTracker.computeCurrentVelocity(1000, maxFlingVelocity);
                    int velocityX = (int) velocityTracker.getXVelocity();
                    int velocityY = (int) velocityTracker.getYVelocity();

                    if (Math.abs(velocityX) > MIN_FLING_VELOCITY || Math.abs(velocityY) > MIN_FLING_VELOCITY) {
                        int startX = horizontalScrollView.getScrollX();
                        int startY = recyclerView.computeVerticalScrollOffset();
                        int maxX = Math.max(0, recyclerView.getWidth() - horizontalScrollView.getWidth());
                        int maxY = Math.max(0, recyclerView.computeVerticalScrollRange() - recyclerView.getHeight());
                        scroller.fling(startX, startY, -velocityX, -velocityY, 0, maxX, 0, maxY);
                        postInvalidateOnAnimation();
                    }
                    isScrolling = false;
                    velocityTracker.recycle();
                    velocityTracker = null;
                    return true;
                }
                return true;

            case MotionEvent.ACTION_CANCEL:
                isScrolling = false;
                if (velocityTracker != null) {
                    velocityTracker.recycle();
                    velocityTracker = null;
                }
                return true;
        }
        return true;
    }

    @Override
    public void computeScroll() {
        if (scroller.computeScrollOffset()) {
            int currX = scroller.getCurrX();
            int currY = scroller.getCurrY();
            int maxX = Math.max(0, recyclerView.getWidth() - horizontalScrollView.getWidth());
            
            currX = Math.max(0, Math.min(maxX, currX));
            horizontalScrollView.scrollTo(currX, 0);
            
            int oldY = recyclerView.computeVerticalScrollOffset();
            int deltaY = currY - oldY;
            recyclerView.scrollBy(0, deltaY);
            
            updateVerticalScrollBar();
            updateHorizontalScrollBar();
            postInvalidateOnAnimation();
        }
    }

    public void search(String query) {
        if (adapter != null) {
            adapter.setSearchQuery(query);
            int lineIndex = adapter.findFirstMatchLine();
            if (lineIndex != -1) {
                ((LinearLayoutManager) recyclerView.getLayoutManager())
                        .scrollToPositionWithOffset(lineIndex, 0);
            }
        }
    }

    public void trimCache() {
        if (adapter != null) {
            adapter.trimCache();
        }
    }
}
